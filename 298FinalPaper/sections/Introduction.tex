\subsection{Outline}
\label{sec:out}
This paper considers the \KS problem, and the practical development of algorithms within a \CC environment. Additionally, we both provide a literature review, and multiple forms of analysis of a variety of algorithms. In sec.~\ref{sec:desc}, we provide a problem description for the \KS problem. In section~\ref{sec:background} a brief literature overview is provided, and then sec.~\ref{sec:AM} describes different performance metrics that can be used when looking at these algorithms. In section~\ref{sec:algDescription}, multiple popular \KS algorithms are described, and a brief list of benefits and drawbacks are provided. We then describe the software implementation for the algorithms in sec.~\ref{sec:implementationDetails}, and some analysis of numerical experiments in sec.~\ref{sec:numExperiments}. Finally, we provide some analysis of results in sec.~\ref{sec:analysis}, and propose future research thrusts in sec.~\ref{sec:conclusion}.

\subsection{Problem Description}
\label{sec:desc}
An instance of the \KS problem can be described by a metric space $M = (X, d)$, a number of servers $k>1$, and an input sequence $\sigma = (r_1, r_2, r_3, ..., r_n)$, which each correspond to a point in the metric space. Each of the $k$ servers is assigned an initial starting location within the metric space (generally this is assumed to be the first $k$ requests of the input sequence). Following this, The sequence of reqeusts is processed one at a time. When a request comes in, a given algorithm \textit{ALG} must decide on one of the servers to service the request. It must then move said server from it's current location $x$ to the request $r_i$. This incurrs a cost of $c = d(x, r_i)$. The goal is to have \textit{ALG} incurr the smallest possible cost while servicing all of the requests in the sequence~\cite{OnlineComp1998}.
\\ \\
There are two major distinctions to be made between different classes of algorithms. The first is the classification of a "lazy" algorithm - one that only moves a server in order to service the current request. Non-lazy algorithms will process a request, and then potentially also move other servers preemptively in order to prepare for future requests. It is important to note that for any non-lazy algorithm that performs well, there is a parallel lazy algorithm that performs just as well, if not better. We can describe this algorithm as follows: suppose we have our non-lazy algorithm, \textit{ALG}. We have the algorithm \textit{LAZY} service requests with the same servers that \textit{ALG} services requests. Suppose that \textit{ALG} moves a server from location $x_1$ to location $x_2$, and then later services request $r_i$ with this server. \textit{LAZY} will be servicing $r_i$ with the same server, except it will be moving from $x_1$ instead of $x_2$. By the triangle inequality, $d(x_1, r_i) \leq d(x_1, x_2) + d(x_2, r_i)$. By applying this principle throughout the request sequence, we will see that the cost of \textit{LAZY} will be as good if not better than that of \textit{ALG}. This shows us that we can create a lazy algorithm from a non-lazy algorithm by maintaining "ghost" locations for servers in relation to how the non-lazy algorithm would use them. Then, we can determine which server the non-lazy algorithm would use, and then service that location with the correct server~\cite{OnlineComp1998}.
\\ \\
The second major distinction is between "online" and "offline" algorithms. An offline algorithm receives the entire request sequence at once, and so as a result is able to make decisions on what server to use for the current request based off of future requests. In contrast, an online algorithm receives the request one at a time, and so is only able to make decisions based off of past requests, the current server configuration, and the current request. While online algorithms are at a severe disadvantage due to this, real world applications often rely on the performance of these algorithms~\cite{OnlineComp1998}. Applications range from disk access optimization, such as the two headed-disk problem \comment{include citation}, to \comment{include other examples, police/firetruck service?}.