//author: Stefan Caldararu
#include "optAlg.h"
#include<cstdlib>
#include<iostream>
#include <utility>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/graph_utility.hpp>
#include <boost/graph/edmonds_karp_max_flow.hpp>
#include <boost/graph/successive_shortest_path_nonnegative_weights.hpp>

using namespace boost;

OptAlg::OptAlg(): Alg()
{}

int OptAlg::runAlg(std::vector <int> Sigma, int inputLength)
{
    typedef adjacency_list_traits<vecS, vecS, directedS> Traits;
    typedef adjacency_list<vecS, vecS, directedS, no_property, property<edge_capacity_t, int, property<edge_residual_capacity_t, int, property<edge_weight_t, int>>>> Graph;
    typedef property_map<Graph, edge_capacity_t>::type EdgeCapacityMap;
    typedef property_map<Graph, edge_residual_capacity_t>::type ResidualCapacityMap;
    typedef property_map<Graph, edge_weight_t>::type EdgeWeightMap;
    typedef graph_traits<Graph>::edge_descriptor Edge;
    //Reference: in notes, 0404017, page 179/180. "NEW RESULTS ON SERVER PROBLEMS, M. CHROBAK"
    int num_nodes = 2+k+2*inputLength;
    Graph g(num_nodes);
    int source = 0;
    int sink = num_nodes-1;
    std::vector<int> s;
    for(int i = 1; i<k+1;i++)
        s.push_back(i);
    std::vector<int> r;
    std::vector<int> rprime;
    for(int i = 0;i<inputLength;i++){
        r.push_back(k+1+2*i);
        rprime.push_back(k+2+2*i);
    }
    //Computing min cost of some max flow code generated by chatGPT using boost.
    Edge e; bool success;

    for(int i = 0; i<k;i++){
        tie(e,success) = add_edge(source,s[i], g);
        tie(get(edge_capacity, g)[e],success) = make_pair(1, true);

    }
    




    int cost = 0;
    //First we need to generate the network flow graph, and then we need to compute the network flow.


    return cost;
}

OptAlg::~OptAlg()
{}